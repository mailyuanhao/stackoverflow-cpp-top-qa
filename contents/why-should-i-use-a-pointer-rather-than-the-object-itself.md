# 我为什么要使用指针而不是对象本身？

我拥有 Java 语言的背景， 现在开始用到 C++ 中的对象。我发现人们更倾向于使用 指针 而不是 对象本身，比如使用下面的代码

```C++
Object *myObject = new Object;
```

而不是这样的

```C++
Object myObject;
```

或者调用函数时 要这样写

```C++
myObject.testFunc();
```

而不是这样：

```C++
myObject->testFunc();
```

我不明白为什么要这样做，我猜测是为了效率和运行速度的原因，因为这样可以直接访问内存地址。我说的对么？

## 评论

- 很不错，你选择了提问而不是盲从。在很多时候指针被滥用了。
- 如果你没有使用指针的理由就不要去使用它。优先选择使用 对象。 对象 优先于 unique_ptr 优先于 shared_ptr 优先于 裸指针。

## 回答

很不幸，让你看到这么频繁的使用动态分配。这说明有很多糟糕的 C++ 程序员。

从某种意义上说，你同时提了两个问题。一个是我们应该在何时使用 动态分配 （new）， 另一个是我们何时使用指针。

一个重要的结论是 选择合适的工具完成工作（always use the appropriate tool for the job）。在绝大多数的情况下，都有比使用动态分配和（或者）指针 更适合，更安全的解决方案。

### 动态分配

在问题里，你给出了两种创建对象的方法。两者主要的区别在于对象的生命周期不同（storage duration）。当在代码块中写下 Ojbect myObject 时， 对象在自动存储周期的，意思是在作用域结束时，对象会被自动释放。 当你写 new Object() 时，对象是动态存储周期的，意思是对象会一直存在到你显示的 delete 它。除非必要不要使用动态分配。就是说只要可以，就要优先选择创建自动变量。

你可能需要使用动态分配的两个主要场景

1. 你需要对象在当前作用域结束后仍然存在（希望这个在特定内存地址的特定对象能够存在，而不是说通过 拷贝、移动 创建新对象也可以）。如果你可以接受这个对象被拷贝，移动（多数情况都是可以的）的新对象，那么选择自动变量。
2. 你需要分配大量的内存(大到可以轻易的耗尽栈)。如果我们不用关心这一点就好了（实际上大多数时候不用关心），因为这已经超出了 C++ 的范畴，但不幸的是，我们必须面对我们代码的实际运行环境的限制。

如果你确实需要动态分配，你应该把他封装到 智能指针 或者其他实现 [RAII](http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization) 的类中 （比如标准库的容器）。智能指针能实现基于所有权的动态分配对象的管理。参考 [unique_ptr](http://en.cppreference.com/w/cpp/memory/unique_ptr) [shared_ptr](http://en.cppreference.com/w/cpp/memory/shared_ptr)如果你适当的使用他们，就可以免于手动管理内存（参考 [rule of zero](https://rmf.io/cxx11/rule-of-zero)）。

### 指针

相对于动态分配，指针的使用范围更加广泛，但是大多数场景都有更优的替代方案。**除非有必要，优先选择使用替代方案**

1. 你需要引用语义。有时你使用传对象（不考虑它是怎么分配出来的）指针的方式调用函数，因为你需要被调用的函数能访问你这个特定的对象（而不是该对象的拷贝）。但是，在大多数情况下，你应该优先选择 引用 而不是 指针， 因为这就是引用被设计出来的原因。注意这儿并不像上述情形 1 说的那样需要延长对象的生命周期。像之前说的那样，如果你可以接受传递对象的拷贝，那么你就不需要使用引用语义。
2. 你需要用到多态，你只能通过对象的指针或者引用来调用多态函数。如果这是你期望的行为，那么使用指针或者引用，再说一遍，引用优先于指针。 
3. 你希望表明某个对象是可选的，当某个对象被忽略时，可以通过传递 nullptr 来表示。如果它是参数，你可以考虑使用默认参数或者函数重载。其余情况可以考虑用一个类型来封装这种行为，比如 C++ 17 可以用 std::optional 之前的 C++ 代码可以使用 boost::optional
4. 你希望解耦编译单元来优化编译时间。 指针一个有用的特性是你仅仅需要一个类的前置声明就可以使用（要操作实际的对象，你仍然需要该类型的定义）。这可以帮助你解耦编译单元，从而可以显著降低编译时间。参考 [Pimpl](http://en.wikipedia.org/wiki/Opaque_pointer) 惯用法。 
5. 你需要和 C 库或者 C 风格的库打交道。这种情况下，你只能使用裸指针。你唯一能做的就是只允许在最后必须的地方才使用裸指针。你可以从智能指针中获得裸指针，比如使用它的 get 成员函数。如果一个库替你执行了分配工作并且期望通过一个句柄去释放这块资源，你可以使用带有指定释放逻辑的智能指针封装该这个句柄，它会在适当的实际释放资源。