# 为什么 C++ 编译需要那么长的时间？

## 回答

好几个因素

### 头文件

每一个独立的编译单元需要加载(1),编译(2)几百甚至几千个头文件。每一个头文件在不同的编译单元中被预处理后可能生成不同的结果（某个编译单元可能定义了某个宏从而会引起头文件被预处理后内容不一样），所以每一个头文件都会被不同的编译单元重复编译。

这可能是最主要的原因，因为每一个编译单元都需要编译大量的代码，并且每一个头文件都要在每一个包含它的编译单元中被重复编译。

### 链接

一旦编译完成，所有的目标文件要被链接到一起，这是一个整体过程基本上无法有效的并行处理，并且需要处理你的整个工程。

### 解析

符号的解析过程极其复杂，而且极度依赖它所在的上下文，并且消除歧义也很困难。这也要消耗大量时间。

### 模板

在 C# 中， List&lt;T&gt; 是唯一需要被编译的类型，不管你有多少个不同的实例化的 List 的版本。在 C++ 中 vector&lt;int&gt; 和 vector&lt;float&gt;是完全不同的类型，需要被分别编译。

补充一点，模板本身就构成了一个编译器需要去编译的图灵完备的子语言，而且编译过程异常复杂。即使是相对简单的模板元编程代码也会定义嵌套的模板，这会生成大量大量的模板实例。模板也会生成名字及其长的极其复杂的类型，这会给链接器产生大量的工作。（链接器需要去比较大量的符号名称，如果每一个名字都数千个字符那么长，这需要相当大的代价）。

当然，它们也会家具头文件的问题，因为模板通常都需要定义到头文件中，这就会造成每一个编译单元都需要解析，编译更多的代码。在 C 语言中，头文件基本上都是前置声明，很少有实际的代码。在 C++ 中，差不多所有代码都放在头文件中并不鲜见。

### 优化

C++ 允许一些非常激进 (dramatic) 的优化。C# 和 Java 并不允许一个类被完全擦除掉（因为反射可能会需要到他们）， 但是即使一个简单的 C++ 模板元编程都会产生几十上百的类，所有的都会被内联处理，然后再被擦除掉。

再者， C++ 的优化完全有编译器来执行。一个 C# 程序可以在加载时依赖 JIT 编译器来做进一步的优化， C++ 程序没有这种 "再次改变“ 的机会。编译器生成的就是最终优化的版本。

### Machine

C++ 被编译成的机器码可能比 Java 或者 .NET 的 字节码更加复杂（特别是在 X86 架构上）。（提出这一点是出于完整性的考虑，因为在评论中有人提到，实际中，这一步的用时相对于整个便器时间来说影响不大）。

### 总结

上述因素中的大多数在 C 语言中也会遇到，但是 C 语言的编译过程却很高效。C++ 的符号解析过程会更加复杂也就需要更多的时间，但是罪魁祸首很大概率就是模板。他们很有用，并且让 C++ 成为了一门更加威力强大的语言，但是他们也要你在编译过程中付出代价。

