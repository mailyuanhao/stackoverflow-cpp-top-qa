# 为什么 C++ 程序员要尽量少的使用 new？

## 回答

有两种常用的内存分配技术： 自动分配和动态分配。通常来说每一种都有对应的内存区域： 栈 和 堆

### 栈

栈总是以顺序的方式分配内存。他可以这么做是因为他总是要求你以相反的顺序释放内存（先进，后出）。这是很多编程语言用于分配临时变量的方式。这种方式特别特别快，因为他所需的内存管理记录信息特别少，总是默认从下一个地址开始分配。

在 C++ 中，这种分配方式被称为 自动存储，因为这种存储空间可以在超出作用域后自动释放。一旦当前代码段（使用 {} 标记）执行结束，所有本代码段的临时变量对应的内存都会自动释放。这也是析构函数被调用来释放资源的时间点。

### 堆

堆是一种更加灵活的内存分配模式。需要更多的内存管理记录信息，所以分配也相对较慢。你必须手动使用 delete 或者 delete[] (C 语音用 free)来释放内存，因为并没有默认内存释放的点。不过没有默认释放点恰恰是 堆分配更加灵活的关键。

### 使用动态分配的原因

虽然使用堆分配内存更慢而且可能会引发内存泄露或者内存碎片，但是也有很多场景更适合使用 动态分配，因为他的限制更少：

使用动态分配的两个关键原因：
- 在编译期你无法预知需要内存的长度。比如，把一个文件读取到一个字符串中，你通常并不知道文件的长度，所以知道程序运行之前都无法得知需要分配多少内存
- 你希望分配的内存在当前代码段结束后能持续存在。例如：你可能会写一个函数用于返回文件的内容 string readFile(string path)。 这种情况下，即使栈能够保存整个文件内容，你也没有办法保留这块内存然后把它从函数中返回。

### 为什么动态分配通常并不是必须的？

C++ 有一个叫做析构函数的功能。这个机制允许你管理资源时把资源的生命周期和变量的生命周期对齐。这种技术叫做 [RAII](http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization) 这是 C++ 与众不同的地方。他把资源封装到对象里面， std::string 就是一个完美的例子。 

```C++
int main ( int argc, char* argv[] )
{
    std::string program(argv[0]);
}
```

上面的代码实际上会分配一段不定长的内存。 std::string 在堆上分配内存然后在析构函数里面释放内存。这种例子里，你不需要手动管理任何资源也可以得到动态内存分配的好处。

特别是，在这个片段中它暗示着：

```C++
int main ( int argc, char* argv[] )
{
    std::string * program = new std::string(argv[0]);  // Bad!
    delete program;
}
```

并没有动态分配内存的必要。需要更多的编码而且会有忘记释放的风险。这样做并没有明显的好处。

### 为什么你要尽可能的使用自动内存分配

最后一段做个总结。尽可能的使用自动内存分配可以让你的程序：

- 编码更快
- 运行更快
- 更少的内存，资源泄露可能
