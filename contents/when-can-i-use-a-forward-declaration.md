# 什么时候可以使用前置声明 ？

我想知道什么情况下允许在另一个类的头文件里面使用一个类的前置声明？

我可以把前置声明的类作为基类么？用前置声明来定义成员变量呢？把前置声明的类以引用的方式传入成员方法呢？

## 回答

你可以从编译器的角度来思考这个问题，当你前置声明了一个类型，编译器唯一知道的事情是这个 类型 是存在的； 它无法得知这个类型的 大小， 成员 或者 方法。这就是为什么前置声明的类型被叫做不完全类型（incomplete type）。 这就是你为什么不能使用前置声明作为基类或者定义成员变量的原因，因为编译器需要知道类型的布局信息。

假设下面的前置声明

```C++
class X;
```

下面列出你可以用它来做什么不能做什么

### 使用一个不完整类型你可以做什么

#### 声明一个指向该不完整类型的指针或者引用成员

```C++
class Foo {
    X *pt;
    X & pt;
};
```

#### 声明一个接受不完整类型作为参数（或者返回一个不完整类型）的方法或者函数

```C++
void f1(X);
X    f2();
```

#### 定义一个接受，返回 不完整类型 指针，引用的 方法、函数（但是不能访问该类型的成员）

```C++
void f3(X*, X&) {}
X&   f4()       {}
X*   f5()       {}
```

### 你不能使用不完整类型做什么

#### 作为基类使用

```C++
class Foo : X {} // compiler error!
```

#### 使用它声明成员

```C++
class Foo {
    X m; // compiler error!
};

#### 定义使用该类型的方法，函数

```C++

void f1(X x) {} // compiler error!
X    f2()    {} // compiler error!

```

#### 访问他的方法或者成员，实际上就是解引用一个不完整类型的变量

```C++

class Foo {
    X *m;
    void method()
    {
        m->someMethod();      // compiler error!
        int i = m->someField; // compiler error!
    }
};

```

---

说道模板，也没有特殊的规则。你是否能使用不完整类型作为模板参数取决于在模板里面该类型是怎么使用的。

例如： std::vector&lt;T&gt;, 要求他的实例化参数必须是完整类型，而 boost::container::vector&lt;T&gt; 就不要求。有时候，仅在你使用特定成员函数时才需要完整类型；参考这个[例子](https://stackoverflow.com/questions/6012157/is-stdunique-ptrt-required-to-know-the-full-definition-of-t);

一个文档齐全的模板应该在文档中明确的指明参数的要求，包括他们是否必须是完整类型。

