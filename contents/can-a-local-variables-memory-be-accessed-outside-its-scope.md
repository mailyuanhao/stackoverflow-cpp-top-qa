# 局部变量的内存能在作用域之外访问么？

我写了如下代码

```C++
#include <iostream>

int * foo()
{
    int a = 5;
    return &a;
}

int main()
{
    int* p = foo();
    std::cout << *p;
    *p = 8;
    std::cout << *p;
}
```

这段代码能正常运行，而且没有报运行时错误。

输出 是 5 8

这是怎么做到的？ 局部变量的内存不应该是不允许从函数外部访问的么?

## 回答

> 这是怎么做到的？ 局部变量的内存不应该是不允许从函数外部访问的么?

你在宾馆订了个房间，睡觉之前在床头柜的最上层抽屉里放了本书，第二天早上退房时你“忘记”归还房间钥匙。你偷了钥匙！

一周后，你回到那个宾馆，没有订房间，直接使用偷的钥匙偷偷进入了上一次的房间然后打开抽屉。你的书还在那儿，意想不到！

**这怎么可以？你没订房之前，房间的抽屉不是不能去打开么？**

好吧，很明显这个场景在现实世界中是可以发生的。并没有什么神秘的力量在你不被允许进入房间时，把你的书隐藏起来。也没有什么神秘的力量阻止你使用偷盗的钥匙进入房间。

宾馆的管理规定并不要求清理你的书。你并没有和他们约定，在你离开后他们有义务销毁掉你的书。如果你使用偷来的钥匙非法重新进入那个房间来拿回你的书，宾馆的保安也没有要求要抓到你的潜入行为。你也没有和他们约定：如果我后续潜入这个房间，你们要阻止我。相反你打破了你和他们做的约定：我保证以后不潜入这个房间，

在这种情况下*任何事情都可能发生*， 如果你足够幸运，你可以找到你的书。也可能那儿放的是别人的书，你的已经被扔到宾馆的火炉里面去了。你进入的时候房间里可能正有另一个人在撕烂你的书。宾馆可能已经移走了床头柜，取而代之的是一个衣柜。宾馆可能正在被拆除，给足球场腾地方，在你潜入的时候，很可能死于一次爆破。

在非法使用一把退房时偷盗的钥匙时，你无法预知会发生什么？ 你打破了系统的规则所以你将处于一个无可预知的不安全的境地。

**C++ 不是一门安全的语言**， 他并不介意你打破系统规则。如果你尝试做一些非法的事情并且愚蠢到进入一个不被允许进入的房间然后翻腾一个可能并不存在的柜子时，C++ 并不会阻止你。比 C++ 更安全的语言通过限制你的能力来解决这个问题， 比如采取更严格的钥匙管理。

### 更新

我的天，这个答案竟然得到这么多的关注。（我并不确定为什么 -- 我认为他只是一个有趣的类比而已。但是无所谓了）

我认为有必要做一些和技术关联度更高的更新了。

编译器的一项重要任务就是生成管理程序所使用数据的存储空间的代码。有很多种生成管理内存代码的方式，但是长久以来有两种方式是一直存在的。

第一种方式是生成 “长期有效” 的存储空间，这种空间的每一个字节的生命周期——也就是说和该存储空间绑定的程序的变量的有效期——无法简单有效的预知。编译器生成代码调用 “堆管理器” 也就是广为熟知的动态分配方式，来分配存储空间然后在不需要时再回收这块空间。

第二种方式是 短期存在 的存储空间，这种情况下每个字节的生命周期是已知的。这种命周期遵循一种嵌套的模式。 这些变量中生命周期长的将会比短的分配的早，同时释放的晚。生命周期较短的变量相对较长的变量分配的会更晚但是释放的更早。短周期变量的生命周期嵌套在长寿命周期变量的内部。

局部变量遵循第二种模式，当进入一个方法体时，他的局部变量就生效了。当该方法调用另一个方法时，新方法的局部变量就会生效。他们的释放将会早于第一个方法局部变量的释放。局部变量关联的存储空间的生命周期的相对开始和结束时间是可以事先确定的。

基于这个原因，局部变量通常分配在一个叫 栈 的数据结构上，因为栈的特性就是先进后出。

这就像宾馆决定只按房间号顺序来出租房间，并且在所有房间号比你高的人退房之前，你无法退房。

让我们来看一下栈的细节。在很多操作系统上每个线程都会对应一个长度固定的栈。当你调用一个方法，局部变量被放到栈顶。如果你把一个指向栈地址的指针返回给上层方法，就像你问题中所说的那样， 这仅仅是一个指向数 M 长的有效内存空间中某个地址的指针而已。在我们的类比中，当你退房时，你退的是当前被出租的房间中房间号最高的房间。如果在你之后没有人来订房，然后你非法进入了这个房间，那么所有你的东西还会在那儿没人去动。

使用栈来存储临时变量是因为它足够的简单开销足够的小。C++ 的实现并不要求一定要用栈来存储临时变量，他也可以使用堆。之所以不这么做是因为这样会让程序更慢。

C++ 的实现并不要求去保证当栈收缩时，曾经使用地址仍然被映射到内存中。具体实现允许去通知操作系统：我已经不再使用栈的这个页面了，在我反悔之前，当有人访问曾经有效的页面时，触发一个退出进程的异常。再说一次，实现之所以不这么做是因为这样会降低效率而且没有必要。

相反，具体的实现会允许你犯错，在大多数时候并不会出问题。直到有一天发生了真正可怕的事情然后进程崩溃了。

这是有问题的。需要遵守的规则有很多而且很容易不注意就打破了。我当然也有过多次。更糟糕的是问题经常在检测到内存错乱后才显现，距离错乱发生点已经数十亿纳秒了，再去查找谁引起的内存错乱变得相当困难。

更加内存安全的语言通过限制你的能力来解决此类问题。”通常‘ C# 里面没有办法获取局部变量的指针然后返回它或者存储备用。你可以获取局部变量的指针，但是语言很巧妙的设计成让你没有办法在生命周期结束后再去使用他。为了获取局部变量的地址然后返回他，你需要让编译器以不安全的模式工作，方法是在你的程序里面加上 unsafe 字段，来提醒你你正在做一些可能打破规则的危险的事情。

扩展阅读：

- [如果 C# 允许返回引用会怎么样？](http://blogs.msdn.com/b/ericlippert/archive/2011/06/23/ref-returns-and-ref-locals.aspx)
- [为什么使用栈来管理内存？](https://blogs.msdn.microsoft.com/ericlippert/tag/memory-management/)